name: '🤖 Gemini Triage & Implement'

on:
  issues:
    types: [opened]
  issue_comment:
    types: [created]

defaults:
  run:
    shell: bash

jobs:
  # -------------------------------------------------------------------------
  # JOB 1: TRIAGE - Runs when a new issue is opened.
  # Analyzes the issue, labels it, and proposes an implementation plan.
  # -------------------------------------------------------------------------
  triage:
    runs-on: ubuntu-latest
    permissions:
      contents: read # Read codebase for context
      issues: write  # Write labels and comments
      pull-requests: write # Required for gh cli, even if not creating a PR
    
    # Only run on newly opened issues
    if: github.event_name == 'issues' && github.event.action == 'opened'

    steps:
      - name: 'Checkout Repository'
        uses: actions/checkout@v4
        # Fetch entire history/files for Gemini analysis context
        with:
          fetch-depth: 0

      - name: 'Setup Node.js'
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          
      - name: 'Install Gemini CLI'
        run: npm install -g @google/gemini-cli

      - name: 'Analyze Issue & Generate Plan'
        id: gemini_analysis
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          ISSUE_TITLE: ${{ github.event.issue.title }}
          ISSUE_BODY: ${{ github.event.issue.body }}
        run: |
          # Prompt Gemini to output a structured JSON response for labels and the plan.
          # The system instruction guides the model to analyze the codebase (current directory).
          ANALYSIS=$(gemini "Analyze the codebase available in the current directory against this GitHub Issue (Title: ${ISSUE_TITLE}, Body: ${ISSUE_BODY}).

          Provide a single JSON object with two fields:
          1. 'labels': An array of recommended GitHub labels (e.g., ['bug', 'enhancement', 'priority: high']).
          2. 'plan': A detailed, numbered implementation plan to resolve the issue.

          Output only the JSON object." --format json)

          # Pass the JSON output to the next step
          echo "analysis_json=${ANALYSIS}" >> $GITHUB_OUTPUT

      - name: 'Apply Labels and Post Plan'
        uses: actions/github-script@v7
        with:
          script: |
            const analysis = JSON.parse(core.getInput('analysis_json'));
            const issueNumber = context.issue.number;

            // 1. Apply Labels
            if (analysis.labels && analysis.labels.length > 0) {
              try {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  labels: analysis.labels,
                });
                core.info(`Applied labels: ${analysis.labels.join(', ')}`);
              } catch (error) {
                core.warning(`Failed to apply labels: ${error.message}`);
              }
            }

            // 2. Post Implementation Plan
            const planBody = `
            🤖 **Triage Complete** (Powered by Gemini)

            I've analyzed the request and the current codebase.

            ### 🏷️ Suggested Labels:
            ${analysis.labels.map(label => `- \`${label}\``).join('\n')}

            ### 📝 Proposed Implementation Plan:
            ${analysis.plan}

            ---
            If this plan looks good, please respond with \`@gemini-cli implement\` to start the automated code generation and Pull Request process.
            `;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body: planBody
            });

  # -------------------------------------------------------------------------
  # JOB 2: IMPLEMENT - Runs when a user confirms the plan with a command.
  # Generates code, commits it to a new branch, and creates a Pull Request.
  # -------------------------------------------------------------------------
  implement:
    runs-on: ubuntu-latest
    permissions:
      contents: write       # Required to push code to a new branch
      pull-requests: write  # Required to create the Pull Request
      issues: write         # Required to comment on the issue
    
    # Only run on issue comments containing the specific command
    if: |
      github.event_name == 'issue_comment' && 
      github.event.action == 'created' && 
      contains(github.event.comment.body, '@gemini-cli implement')

    steps:
      - name: 'Checkout Repository'
        uses: actions/checkout@v4
        with:
          # Checkout to a new branch name based on the issue number
          ref: ${{ github.ref }}
          fetch-depth: 0

      - name: 'Setup Node.js'
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: 'Install Gemini CLI'
        run: npm install -g @google/gemini-cli
        
      - name: 'Generate Code Changes'
        id: gemini_code
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          ISSUE_TITLE: ${{ github.event.issue.title }}
          ISSUE_BODY: ${{ github.event.issue.body }}
          BRANCH_NAME: gemini-fix/issue-${{ github.event.issue.number }}
        run: |
          # 1. Create a new branch for the implementation
          git checkout -b "${BRANCH_NAME}"
          echo "branch_name=${BRANCH_NAME}" >> $GITHUB_OUTPUT
          
          # 2. Get code generation from Gemini
          echo "## Fetching code changes from Gemini..."
          # The model analyzes the codebase (current directory) and the original issue.
          gemini "Based on the following GitHub Issue and the provided codebase in the current directory, generate the complete, ready-to-commit code changes to implement the fix/feature. Output only the content of the files that need to be created or modified. Use the standard file block format: \`\`\`{language}:{Title}:{filepath}\n...code...\n\`\`\`eof" > gemini_output.txt

          # 3. Parse and write files
          # This Node.js script parses the file blocks, creates directories, and writes the code.
          node -e "
            const fs = require('fs');
            const path = require('path');
            
            let filesWrittenCount = 0;
            try {
              const content = fs.readFileSync('gemini_output.txt', 'utf8');
              
              // Regex to find all file blocks: 
