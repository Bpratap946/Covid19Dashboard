name: 'ü§ñ Gemini Triage & Implement'

on:
  issues:
    types: [opened]
  issue_comment:
    types: [created]

defaults:
  run:
    shell: bash

jobs:
  # -------------------------------------------------------------------------
  # JOB 1: TRIAGE - Runs when a new issue is opened.
  # Analyzes the issue, labels it, and proposes an implementation plan.
  # -------------------------------------------------------------------------
  triage:
    runs-on: ubuntu-latest
    permissions:
      contents: read # Read codebase for context
      issues: write  # Write labels and comments
      pull-requests: write # Required for gh cli, even if not creating a PR
    
    # Only run on newly opened issues
    if: github.event_name == 'issues' && github.event.action == 'opened'

    steps:
      - name: 'Checkout Repository'
        uses: actions/checkout@v4
        # Fetch entire history/files for Gemini analysis context
        with:
          fetch-depth: 0

      - name: 'Setup Node.js'
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          
      - name: 'Install Gemini CLI'
        run: npm install -g @google/gemini-cli

      - name: 'Analyze Issue & Generate Plan'
        id: gemini_analysis
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          ISSUE_TITLE: ${{ github.event.issue.title }}
          ISSUE_BODY: ${{ github.event.issue.body }}
        run: |
          # Prompt Gemini to output a structured JSON response for labels and the plan.
          # The system instruction guides the model to analyze the codebase (current directory).
          ANALYSIS=$(gemini "Analyze the codebase available in the current directory against this GitHub Issue (Title: ${ISSUE_TITLE}, Body: ${ISSUE_BODY}).

          Provide a single JSON object with two fields:
          1. 'labels': An array of recommended GitHub labels (e.g., ['bug', 'enhancement', 'priority: high']).
          2. 'plan': A detailed, numbered implementation plan to resolve the issue.

          Output only the JSON object." --format json)

          # Pass the JSON output to the next step
          echo "analysis_json=${ANALYSIS}" >> $GITHUB_OUTPUT

      - name: 'Apply Labels and Post Plan'
        uses: actions/github-script@v7
        with:
          script: |
            const analysis = JSON.parse(core.getInput('analysis_json'));
            const issueNumber = context.issue.number;

            // 1. Apply Labels
            if (analysis.labels && analysis.labels.length > 0) {
              try {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  labels: analysis.labels,
                });
                core.info(`Applied labels: ${analysis.labels.join(', ')}`);
              } catch (error) {
                core.warning(`Failed to apply labels: ${error.message}`);
              }
            }

            // 2. Post Implementation Plan
            const planBody = `
            ü§ñ **Triage Complete** (Powered by Gemini)

            I've analyzed the request and the current codebase.

            ### üè∑Ô∏è Suggested Labels:
            ${analysis.labels.map(label => `- \`${label}\``).join('\n')}

            ### üìù Proposed Implementation Plan:
            ${analysis.plan}

            ---
            If this plan looks good, please respond with \`@gemini-cli implement\` to start the automated code generation and Pull Request process.
            `;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body: planBody
            });

  # -------------------------------------------------------------------------
  # JOB 2: IMPLEMENT - Runs when a user confirms the plan with a command.
  # Generates code, commits it to a new branch, and creates a Pull Request.
  # -------------------------------------------------------------------------
  implement:
    runs-on: ubuntu-latest
    permissions:
      contents: write       # Required to push code to a new branch
      pull-requests: write  # Required to create the Pull Request
      issues: write         # Required to comment on the issue
    
    # Only run on issue comments containing the specific command
    if: |
      github.event_name == 'issue_comment' && 
      github.event.action == 'created' && 
      contains(github.event.comment.body, '@gemini-cli implement')

    steps:
      - name: 'Checkout Repository'
        uses: actions/checkout@v4
        with:
          # Checkout to a new branch name based on the issue number
          ref: ${{ github.ref }}
          fetch-depth: 0

      - name: 'Setup Node.js'
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: 'Install Gemini CLI'
        run: npm install -g @google/gemini-cli
        
      - name: 'Generate Code Changes'
        id: gemini_code
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          ISSUE_TITLE: ${{ github.event.issue.title }}
          ISSUE_BODY: ${{ github.event.issue.body }}
          BRANCH_NAME: gemini-fix/issue-${{ github.event.issue.number }}
        run: |
          # 1. Create a new branch for the implementation
          git checkout -b "${BRANCH_NAME}"
          echo "branch_name=${BRANCH_NAME}" >> $GITHUB_OUTPUT
          
          # 2. Get code generation from Gemini
          echo "## Fetching code changes from Gemini..."
          # The model analyzes the codebase (current directory) and the original issue.
          gemini "Based on the following GitHub Issue and the provided codebase in the current directory, generate the complete, ready-to-commit code changes to implement the fix/feature. Output only the content of the files that need to be created or modified. Use the standard file block format: \`\`\`{language}:{Title}:{filepath}\n...code...\n\`\`\`eof" > gemini_output.txt

          # 3. Parse and write files
          # This Node.js script parses the file blocks, creates directories, and writes the code.
          node -e "
            const fs = require('fs');
            const path = require('path');
            
            let filesWrittenCount = 0;
            try {
              const content = fs.readFileSync('gemini_output.txt', 'utf8');
              
              // Regex to find all file blocks: 
              // The non-greedy matching ensures we capture the entire block content, including new lines.
              const fileBlocks = content.match(/```[a-z]+:[^:\\n]+:([^:\\n]+)\n([\s\S]*?)/g);
              
                        if (!fileBlocks || fileBlocks.length === 0) {
                          console.log('No file blocks found in output. Skipping commit.');
                          return;
                        }
              
                        fileBlocks.forEach(block => {
                          // Extract filepath from the header using a non-greedy match
                          // Group 1 captures the filepath: \`\`\`lang:Title:(filepath)\n
                          const headerMatch = block.match(/
              
              // Use a default empty string if match fails
              const code = codeMatch ? codeMatch[1] : '';
              
                            // Ensure directory structure exists
                            const dir = path.dirname(filePath);
                            if (!fs.existsSync(dir)) {
                              fs.mkdirSync(dir, { recursive: true });
                            }
              
                            // Write the code to the file
                            fs.writeFileSync(filePath, code);
                            console.log(\`‚úÖ Wrote file: \${filePath}\`);
                            filesWrittenCount++;
                          } else {
                            console.warn('‚ö†Ô∏è Could not parse file header in block:', block.substring(0, 50) + '...');
                          }
                        });
              
                      } catch (e) {
                        console.error('‚ùå Error during file parsing/writing:', e.message);
                      } finally {
                        // Output the result whether successful or failed
                        console.log(\`files_written=\${filesWrittenCount > 0}\`);
                      }
                    " >> $GITHUB_OUTPUT
              
                - name: 'Commit and Push Changes'
                  # Only proceed if files were successfully generated and written
                  if: steps.gemini_code.outputs.files_written == 'true'
                  env:
                    BRANCH_NAME: ${{ steps.gemini_code.outputs.branch_name }}
                    ISSUE_NUMBER: ${{ github.event.issue.number }}
                  run: |
                    git config --local user.email "action@github.com"
                    git config --local user.name "GitHub Action Bot (Gemini)"
                    git add .
              
                    # Only commit if there are changes staged
                    if ! git diff --staged --quiet; then
                      git commit -m "feat(gemini): Implement fix for #${ISSUE_NUMBER}"
                      git push origin ${BRANCH_NAME}
                      echo "‚úÖ Code committed and pushed."
                    else
                      echo "‚ö†Ô∏è No file changes detected. Skipping commit."
                      # Exit code 1 ensures the subsequent steps that depend on code writing also skip.
                      exit 1
                    fi
              
                - name: 'Create Pull Request'
                  # Only proceed if the commit and push step was successful (implied by no exit 1 from previous step)
                  if: steps.gemini_code.outputs.files_written == 'true'
                  env:
                    GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
                    BRANCH_NAME: ${{ steps.gemini_code.outputs.branch_name }}
                    ISSUE_NUMBER: ${{ github.event.issue.number }}
                  run: |
                    PR_TITLE="ü§ñ Implemented: Fix/Feature for #${ISSUE_NUMBER}"
                    PR_BODY="Automated PR generated by the Gemini Action.
              Closes #${ISSUE_NUMBER}"
              
                    # Use 'gh pr create' to make the PR
                    gh pr create \
                      --base master \
                      --head ${BRANCH_NAME} \
                      --title "${PR_TITLE}" \
                      --body "${PR_BODY}" \
                      --repo ${{ github.repository }}
                    
                    # Add a comment to the original issue linking the PR
                    PR_URL=$(gh pr list --head ${BRANCH_NAME} --json url -q '.[0].url' || true)
                    if [ -z "$PR_URL" ]; then
                      MESSAGE="‚ö†Ô∏è Code generation complete, but failed to create a Pull Request. Please check the logs."
                    else
                      MESSAGE="‚úÖ Code generation complete! A Pull Request has been opened for your review: ${PR_URL}"
                    fi
              
                    gh issue comment ${ISSUE_NUMBER} \
                      --body "${MESSAGE}" \
                      --repo ${{ github.repository }}
